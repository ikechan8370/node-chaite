import {
  AbstractShareable,
  BaseClientOptions,
  ChannelsLoadBalancer,
  ChannelStatistics,
  ClientType,
  Wait,
} from '../types/index.js'
import { CHANNEL_STATUS_MAP } from '../const/index.js'

export class DefaultChannelLoadBalancer implements ChannelsLoadBalancer {
  public constructor() {}

  async getChannel(name: string, channels: Channel[]): Promise<Channel> {
    // 按优先级分组并排序
    const priorityGroups = this.groupByPriority(channels)

    // 按优先级降序选择可用组
    for (const group of priorityGroups) {
      const availableChannels = group.filter(c => c.status === 'enabled')

      if (availableChannels.length > 0) {
        return this.selectByWeight(availableChannels)
      }
    }

    throw new Error('No available channels')
  }

  // 按优先级分组并降序排列
  private groupByPriority(channels: Channel[]): Channel[][] {
    const priorityMap = new Map<number, Channel[]>()

    channels.forEach(channel => {
      const group = priorityMap.get(channel.priority) || []
      group.push(channel)
      priorityMap.set(channel.priority, group)
    })

    return Array.from(priorityMap.keys())
      .sort((a, b) => b - a) // 降序排列
      .map(priority => priorityMap.get(priority)!)
  }

  // 在相同优先级内按权重选择
  private selectByWeight(channels: Channel[]): Channel {
    const totalWeight = channels.reduce((sum, c) => sum + c.weight, 0)
    let random = Math.random() * totalWeight

    for (const channel of channels) {
      random -= channel.weight
      if (random <= 0) {
        return channel
      }
    }
    return channels[0]
  }

  /**
   * 获取渠道列表及其分配的数量
   * generated by qwen-2.5-max
   *
   * @param modelName 模型名称
   * @param channels 渠道列表
   * @param totalQuantity 总数量
   * @returns 返回一个包含渠道及其分配数量的数组
   */
  async getChannels(modelName: string, channels: Channel[], totalQuantity: number): Promise<{ channel: Channel; quantity: number }[]> {
    // 筛选出支持该模型的渠道
    const supportedChannels = channels.filter(channel => channel.models.includes(modelName))

    if (supportedChannels.length === 0) {
      throw new Error('No channels support the specified model')
    }

    // 按优先级分组并排序
    const priorityGroups = this.groupByPriority(supportedChannels)

    // 只选择优先级最高的组
    const highestPriorityGroup = priorityGroups[0]

    if (!highestPriorityGroup || highestPriorityGroup.length === 0) {
      throw new Error('No available channels with the highest priority')
    }

    // 计算总权重
    const totalWeight = highestPriorityGroup.reduce((sum, c) => sum + c.weight, 0)

    // 根据权重分配数量
    const result: { channel: Channel; quantity: number }[] = []
    let remainingQuantity = totalQuantity

    for (const channel of highestPriorityGroup) {
      const allocatedQuantity = Math.floor((channel.weight / totalWeight) * totalQuantity)
      result.push({ channel, quantity: allocatedQuantity })
      remainingQuantity -= allocatedQuantity
    }

    // 将剩余的数量分配给第一个渠道（避免因取整导致数量不足）
    if (remainingQuantity > 0 && result.length > 0) {
      result[0].quantity += remainingQuantity
    }

    return result
  }
}

/**
 * 渠道
 * 每个渠道对应一个adapter，并记录客户端的options
 */
export class Channel extends AbstractShareable<Channel> implements Wait {
  constructor(id: string, models: string[], adapterType: ClientType, options: BaseClientOptions, name: string, type: ClientType, status: 'enabled' | 'disabled', statistics: ChannelStatistics, weight?: number, priority?: number, disabledReason?: string) {
    super()
    this.modelType = 'settings'
    this.id = id
    this.models = models
    this.adapterType = adapterType
    this.options = options
    this.name = name
    this.type = type
    this.weight = weight || 1
    this.priority = priority || 1
    this.status = status
    this.disabledReason = disabledReason
    this.statistics = statistics
    this.init()
  }

  async init() {
    return this.options.ready()
  }

  async ready(): Promise<void> {
    await this.init()
  }

  adapterType: ClientType
  options: BaseClientOptions
  models: string[]
  id: string
  name: string
  type: ClientType
  weight: number
  priority: number
  status: 'enabled' | 'disabled'
  disabledReason?: string
  statistics: ChannelStatistics

  fromString(str: string): Channel {
    const channel = JSON.parse(str)
    return new Channel(channel.id, channel.adapterType, channel.models, new BaseClientOptions().fromString(channel.options), channel.name, channel.type, channel.status, new ChannelStatistics().fromString(channel.statistics), channel.weight, channel.priority, channel.disabledReason)
  }

  toString(): string {
    const toJsonStr = {
      id: this.id,
      models: this.models,
      adapterType: this.adapterType,
      options: this.options.toString(),
      name: this.name,
      type: this.type,
      weight: this.weight,
      statistics: this.statistics.toString(),
      status: this.status,
      priority: this.priority,
      disabledReason: this.disabledReason,
    }
    return JSON.stringify(toJsonStr)
  }

  toFormatedString(verbose: boolean = false): string {
    let base = `渠道ID：${this.id}\n渠道名称：${this.name} \n渠道类型：${this.type}\n渠道状态：${CHANNEL_STATUS_MAP[this.status]}\n渠道权重：${this.weight}\n渠道优先级：${this.priority}\n渠道禁用原因：${this.disabledReason}\n支持模型：${this.models.join(', ')}\n`
    if (verbose) {
      base += `BaseURL: ${this.options.baseUrl}\nAPI Key：${Array.isArray(this.options.apiKey) ? this.options.apiKey.join(',') : this.options.apiKey}\n`
    }
    base += `创建时间：${this.createdAt}\n最后更新时间：${this.updatedAt}\n上传者：${this.uploader.username ? ('@' + this.uploader.username) : ''}`
    return base.trimEnd()
  }
}